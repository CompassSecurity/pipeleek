package jobtoken

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/config"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	"github.com/google/go-github/v69/github"
	"github.com/rs/zerolog/log"
)

const (
	defaultCommitMessage = "Add jobToken env dump job"
	branchPrefix         = "pipeleek-"
)

func Run(githubUrl, githubToken, repoPath string) {
	// Parse owner and repo from repoPath
	parts := strings.Split(repoPath, "/")
	if len(parts) != 2 {
		log.Fatal().Str("repo", repoPath).Msg("Repository must be in format owner/repo")
	}
	owner, repoName := parts[0], parts[1]

	// Create GitHub client using the SDK
	ctx := context.Background()
	client := github.NewClient(nil).WithAuthToken(githubToken)
	if githubUrl != "" && githubUrl != "https://api.github.com" && githubUrl != "https://api.github.com/" {
		var err error
		// For enterprise, the SDK expects the base URL without /api/v3
		client, err = client.WithEnterpriseURLs(githubUrl, githubUrl)
		if err != nil {
			log.Fatal().Stack().Err(err).Str("url", githubUrl).Msg("Failed to create GitHub client with enterprise URL")
		}
	}

	// Validate token and get user information
	user, resp, err := client.Users.Get(ctx, "")
	if err != nil {
		status := 0
		if resp != nil {
			status = resp.StatusCode
		}
		log.Fatal().Stack().Err(err).Int("status", status).Msg("Failed to validate token - token may be expired or invalid")
	}

	log.Info().Msg("GitHub Actions token validation succeeded")
	if user.Login != nil {
		log.Info().Str("user", *user.Login).Msg("Token authenticated as user")
	}

	// Get repository information
	repo, resp, err := client.Repositories.Get(ctx, owner, repoName)
	if err != nil {
		status := 0
		if resp != nil {
			status = resp.StatusCode
		}
		log.Fatal().Stack().Err(err).Int("status", status).Str("repo", repoPath).Msg("Failed fetching repository - check token permissions")
	}

	log.Info().
		Str("repo", *repo.FullName).
		Str("visibility", *repo.Visibility).
		Str("default_branch", *repo.DefaultBranch).
		Msg("Repository information retrieved")

	// Check token scopes
	if resp.Header != nil {
		scopes := resp.Header.Get("X-OAuth-Scopes")
		if scopes != "" {
			log.Info().Str("scopes", scopes).Msg("Token OAuth scopes detected")
		}
	}

	// Important warning about token scope
	log.Warn().Msg("‚ö†Ô∏è  IMPORTANT: You must manually review the token's access scope for exploitation")
	log.Warn().Msg("‚ö†Ô∏è  GitHub Actions GITHUB_TOKEN has limited default permissions (usually read-only)")
	log.Warn().Msg("‚ö†Ô∏è  Check the workflow's permissions: https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication#permissions-for-the-github_token")

	defaultBranch := repo.GetDefaultBranch()
	if defaultBranch == "" {
		log.Fatal().Msg("Repository has no default branch")
	}

	branchName, err := generateBranchName()
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed to generate branch name")
	}

	// Attempt to clone and push to demonstrate token capabilities
	cloneURL := repo.GetCloneURL()
	if cloneURL == "" {
		log.Fatal().Msg("Repository clone URL is empty")
	}

	if err := attemptCloneAndPush(cloneURL, githubToken, defaultBranch, branchName, repoPath); err != nil {
		log.Warn().Stack().Err(err).Str("branch", branchName).Msg("Could not write to the repo with this token (check token permissions)")
		return
	}

	log.Info().Str("repo", *repo.HTMLURL).Str("branch", branchName).Msg("Successfully cloned and created branch with the GitHub Actions token")
	log.Info().Str("url", fmt.Sprintf("%s/tree/%s", *repo.HTMLURL, branchName)).Msg("Review branch changes")
}

func generateBranchName() (string, error) {
	randomBytes := make([]byte, 4)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", err
	}

	return branchPrefix + hex.EncodeToString(randomBytes), nil
}

func attemptCloneAndPush(cloneURL, githubToken, defaultBranch, branchName, repoPath string) error {
	parentDir, err := os.MkdirTemp("", "pipeleek-jobtoken-")
	if err != nil {
		return err
	}
	defer func() {
		_ = os.RemoveAll(parentDir)
	}()

	cloneDir := filepath.Join(parentDir, "repo")
	auth := &http.BasicAuth{
		Username: "x-access-token", // GitHub uses this as username for token auth
		Password: githubToken,
	}

	log.Info().Str("repo", repoPath).Msg("Attempting to clone repository with token...")
	repo, err := git.PlainClone(cloneDir, false, &git.CloneOptions{
		URL:           cloneURL,
		Auth:          auth,
		Depth:         1,
		SingleBranch:  true,
		ReferenceName: plumbing.NewBranchReferenceName(defaultBranch),
	})
	if err != nil {
		return fmt.Errorf("failed to clone repository (token may lack read access): %w", err)
	}
	log.Info().Str("dir", cloneDir).Str("branch", defaultBranch).Msg("Successfully cloned repository")

	worktree, err := repo.Worktree()
	if err != nil {
		return err
	}

	if err := worktree.Checkout(&git.CheckoutOptions{
		Branch: plumbing.NewBranchReferenceName(branchName),
		Create: true,
	}); err != nil {
		return err
	}
	log.Debug().Str("branch", branchName).Msg("Checked out new branch")

	proofPath := filepath.Join(cloneDir, "proof.txt")
	proofContent := "Pipeleek demonstrated GitHub Actions token access üèÜ"
	if err := os.WriteFile(proofPath, []byte(proofContent), 0o644); err != nil {
		return fmt.Errorf("failed writing proof.txt: %w", err)
	}
	log.Debug().Str("path", proofPath).Msg("Wrote proof.txt")

	if _, err := worktree.Add("proof.txt"); err != nil {
		return err
	}
	log.Debug().Str("file", "proof.txt").Msg("Staged proof.txt")

	if _, err := worktree.Commit(defaultCommitMessage, &git.CommitOptions{
		Author: &object.Signature{
			Name:  "pipeleek",
			Email: "noreply@pipeleek.local",
			When:  time.Now(),
		},
	}); err != nil {
		return err
	}
	log.Debug().Str("message", defaultCommitMessage).Msg("Committed proof.txt")

	log.Info().Str("branch", branchName).Msg("Attempting to push branch (this tests write access)...")
	if err := repo.Push(&git.PushOptions{
		Auth: auth,
		RefSpecs: []config.RefSpec{
			config.RefSpec("refs/heads/" + branchName + ":refs/heads/" + branchName),
		},
	}); err != nil && err != git.NoErrAlreadyUpToDate {
		return fmt.Errorf("failed to push branch (token may lack write access): %w", err)
	}
	log.Debug().Str("branch", branchName).Msg("Pushed branch successfully")

	return nil
}
