package ghtoken

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/config"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	"github.com/google/go-github/v69/github"
	"github.com/rs/zerolog/log"
)

const (
	defaultCommitMessage = "Add ghtoken env dump job"
	branchPrefix         = "pipeleek-"
)

func Run(githubUrl, githubToken, repoPath string) {
	// Parse owner and repo from repoPath
	parts := strings.Split(repoPath, "/")
	if len(parts) != 2 {
		log.Fatal().Str("repo", repoPath).Msg("Repository must be in format owner/repo")
	}
	owner, repoName := parts[0], parts[1]

	ctx := context.Background()
	client := github.NewClient(nil).WithAuthToken(githubToken)
	if githubUrl != "" && githubUrl != "https://api.github.com" && githubUrl != "https://api.github.com/" {
		var err error
		client, err = client.WithEnterpriseURLs(githubUrl, githubUrl)
		if err != nil {
			log.Fatal().Stack().Err(err).Str("url", githubUrl).Msg("Failed to create GitHub client with enterprise URL")
		}
	}

	// Validate token by accessing the repository via the API
	var (
		repo          *github.Repository
		resp          *github.Response
		err           error
		defaultBranch string
		cloneURL      string
	)
	repo, resp, err = client.Repositories.Get(ctx, owner, repoName)
	if err != nil {
		status := 0
		if resp != nil {
			status = resp.StatusCode
		}
		if status == 403 {
			cloneURL = buildCloneURL(githubUrl, owner, repoName)
			log.Warn().Stack().Err(err).Int("status", status).Str("repo", repoPath).Msg("Repo API access blocked; falling back to git-only validation")
		} else {
			log.Fatal().Stack().Err(err).Int("status", status).Str("repo", repoPath).Msg("Failed fetching repository - check token permissions")
		}
	} else {
		log.Info().Msg("GitHub Actions token validation succeeded")
		log.Info().
			Str("repo", repo.GetFullName()).
			Str("visibility", repo.GetVisibility()).
			Str("default_branch", repo.GetDefaultBranch()).
			Msg("Repository information retrieved")

		defaultBranch = repo.GetDefaultBranch()
		cloneURL = repo.GetCloneURL()
		if cloneURL == "" {
			cloneURL = buildCloneURL(githubUrl, owner, repoName)
		}

		// Check token scopes
		if resp != nil && resp.Header != nil {
			scopes := resp.Header.Get("X-OAuth-Scopes")
			if scopes != "" {
				log.Info().Str("scopes", scopes).Msg("Token OAuth scopes detected")
			}
		}
	}

	// Important warning about token scope
	log.Warn().Msg("GitHub Actions GITHUB_TOKEN has limited default permissions (usually read-only)")
	log.Warn().Msg("Check the workflow's permissions manually: https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication#permissions-for-the-github_token")

	branchName, err := generateBranchName()
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed to generate branch name")
	}

	// Attempt to clone and push to demonstrate token capabilities
	if cloneURL == "" {
		log.Fatal().Msg("Repository clone URL is empty")
	}

	if err := attemptCloneAndPush(cloneURL, githubToken, defaultBranch, branchName, repoPath); err != nil {
		log.Warn().Stack().Err(err).Str("branch", branchName).Msg("Could not write to the repo with this token (check token permissions)")
		return
	}

	if repo != nil && repo.HTMLURL != nil {
		log.Info().Str("repo", *repo.HTMLURL).Str("branch", branchName).Msg("Successfully cloned and created branch with the GitHub Actions token")
		log.Info().Str("url", fmt.Sprintf("%s/tree/%s", *repo.HTMLURL, branchName)).Msg("Review branch changes")
	} else {
		log.Info().Str("branch", branchName).Msg("Successfully cloned and created branch with the GitHub Actions token")
	}
}

func generateBranchName() (string, error) {
	randomBytes := make([]byte, 4)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", err
	}

	return branchPrefix + hex.EncodeToString(randomBytes), nil
}

func attemptCloneAndPush(cloneURL, githubToken, defaultBranch, branchName, repoPath string) error {
	parentDir, err := os.MkdirTemp("", "pipeleek-ghtoken-")
	if err != nil {
		return err
	}
	defer func() {
		_ = os.RemoveAll(parentDir)
	}()

	cloneDir := filepath.Join(parentDir, "repo")
	auth := &http.BasicAuth{
		Username: "x-access-token", // GitHub uses this as username for token auth
		Password: githubToken,
	}

	log.Info().Str("repo", repoPath).Msg("Attempting to clone repository with token...")
	cloneOptions := &git.CloneOptions{
		URL:   cloneURL,
		Auth:  auth,
		Depth: 1,
	}
	if defaultBranch != "" {
		cloneOptions.SingleBranch = true
		cloneOptions.ReferenceName = plumbing.NewBranchReferenceName(defaultBranch)
	}

	repo, err := git.PlainClone(cloneDir, false, cloneOptions)
	if err != nil {
		return fmt.Errorf("failed to clone repository (token may lack read access): %w", err)
	}
	if defaultBranch == "" {
		head, headErr := repo.Head()
		if headErr == nil && head.Name().IsBranch() {
			defaultBranch = head.Name().Short()
		}
	}
	log.Info().Str("dir", cloneDir).Str("branch", defaultBranch).Msg("Successfully cloned repository")

	worktree, err := repo.Worktree()
	if err != nil {
		return err
	}

	if err := worktree.Checkout(&git.CheckoutOptions{
		Branch: plumbing.NewBranchReferenceName(branchName),
		Create: true,
	}); err != nil {
		return err
	}
	log.Debug().Str("branch", branchName).Msg("Checked out new branch")

	proofPath := filepath.Join(cloneDir, "proof.txt")
	proofContent := "Pipeleek demonstrated GitHub Actions token access üèÜ"
	if err := os.WriteFile(proofPath, []byte(proofContent), 0o644); err != nil {
		return fmt.Errorf("failed writing proof.txt: %w", err)
	}
	log.Debug().Str("path", proofPath).Msg("Wrote proof.txt")

	if _, err := worktree.Add("proof.txt"); err != nil {
		return err
	}
	log.Debug().Str("file", "proof.txt").Msg("Staged proof.txt")

	if _, err := worktree.Commit(defaultCommitMessage, &git.CommitOptions{
		Author: &object.Signature{
			Name:  "pipeleek",
			Email: "noreply@pipeleek.local",
			When:  time.Now(),
		},
	}); err != nil {
		return err
	}
	log.Debug().Str("message", defaultCommitMessage).Msg("Committed proof.txt")

	log.Info().Str("branch", branchName).Msg("Attempting to push branch (this tests write access)...")
	if err := repo.Push(&git.PushOptions{
		Auth: auth,
		RefSpecs: []config.RefSpec{
			config.RefSpec("refs/heads/" + branchName + ":refs/heads/" + branchName),
		},
	}); err != nil && err != git.NoErrAlreadyUpToDate {
		return fmt.Errorf("failed to push branch (token may lack write access): %w", err)
	}
	log.Debug().Str("branch", branchName).Msg("Pushed branch successfully")

	return nil
}

func buildCloneURL(githubUrl, owner, repoName string) string {
	if githubUrl == "" || githubUrl == "https://api.github.com" || githubUrl == "https://api.github.com/" {
		return fmt.Sprintf("https://github.com/%s/%s.git", owner, repoName)
	}

	base := strings.TrimSuffix(githubUrl, "/")
	if idx := strings.Index(base, "/api/"); idx != -1 {
		base = base[:idx]
	}

	return fmt.Sprintf("%s/%s/%s.git", base, owner, repoName)
}
