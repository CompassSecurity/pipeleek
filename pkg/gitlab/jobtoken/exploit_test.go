package jobtoken

import (
	"encoding/hex"
	"net/url"
	"strings"
	"testing"
)

func TestGenerateBranchName(t *testing.T) {
	branch, err := generateBranchName()
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if !strings.HasPrefix(branch, branchPrefix) {
		t.Fatalf("expected prefix %q, got %q", branchPrefix, branch)
	}

	raw := strings.TrimPrefix(branch, branchPrefix)
	if len(raw) != 8 {
		t.Fatalf("expected 8 hex characters, got %d", len(raw))
	}

	if _, err := hex.DecodeString(raw); err != nil {
		t.Fatalf("expected hex suffix, got %q", raw)
	}
}

func TestWithJobTokenAuth(t *testing.T) {
	result, err := withJobTokenAuth("https://gitlab.example.com/group/repo.git", "glcbt-123")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	parsed, err := url.Parse(result)
	if err != nil {
		t.Fatalf("unexpected parse error: %v", err)
	}

	user := parsed.User.Username()
	password, _ := parsed.User.Password()
	if user != "gitlab-ci-token" {
		t.Fatalf("expected user gitlab-ci-token, got %q", user)
	}
	if password != "glcbt-123" {
		t.Fatalf("expected token to be preserved")
	}
}

func TestScrubToken(t *testing.T) {
	output := scrubToken("fatal: job token glcbt-123", "glcbt-123")
	if strings.Contains(output, "glcbt-123") {
		t.Fatalf("expected token to be redacted")
	}
	if !strings.Contains(output, "[REDACTED]") {
		t.Fatalf("expected redaction marker")
	}
}

func TestScrubToken_EmptyToken(t *testing.T) {
	output := scrubToken("  output message  ", "")
	if output != "output message" {
		t.Fatalf("expected trimmed output, got %q", output)
	}
}
